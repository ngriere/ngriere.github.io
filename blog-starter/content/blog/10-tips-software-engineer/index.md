---
title: 10 tips for every software engineer
date: "2021-11-04T09:45:00.000Z"
description: "New to the software industry? Wondering what might make the difference between you and another developer in a few years? You've come to the right place!"
---

As a fellow software engineer who has worked for several companies and on various projects since I have joined the industry, here are a few thoughts I would like to share with you. These are things I have either reflected upon, experienced or observed during my short career so far. 
Some of the following might sound obvious to you - excellent! Nevertheless, I feel you can't overemphasize their importance. 
I decided to write this article because, looking back, it is the kind of advice I wish I had read five to seven years ago.

The following tips are not meant to help you ace an interview. 
Like many things in life, becoming a successful software developer takes time and patience. 
They should be things to keep in mind on your route to getting there!

## 1. Don't aim to be a good programmer, aim to be a good software engineer

As you may have noticed, I started this article without defining what an engineer is.

Before I go on, let me share a little bit my background. I graduated from an engineering school in France and work in Paris.
I don't presume the terms ["engineer" or "developper" are universal](https://en.wikipedia.org/wiki/Engineer#Perception).
If you search for job opportunities over here, you'll find: "software engineer", "software developer", you might even encounter "software programmer" (yikes!). 
You'll rarely find the term "coder" which sounds really bad in French. 
Indeed, if you do see that kind of job offer run away! Even among colleagues and friends, we don't all use the same term. 
Some define themselves as developers, others as engineers etc.

I will not give exhaustive definitions of these terms, these articles discuss thoroughly the difference:

[Programmer Vs Developer Vs Engineer](https://medium.com/shakuro/programmer-vs-developer-vs-engineer-91ef374e5033)

[Software Engineer vs. Programmer: What's the Difference?](https://medium.com/r/?url=https%3A%2F%2Fbuiltin.com%2Frecruiting%2Fsoftware-engineer-vs-programmer)

I will however say this: there is a clear distinction between these terms. 
I personally don't make the distinction based on an academic or job title. I do make one based on a job description.

An engineer will understand a business need and modelize the problem. 
He will be able to design and implement a solution along with tests that validate the requirements.

If you really want to build good software, you can't be "just coding". 
There are many other steps involved in the development process. Coding probably takes 20 to 25% of your time. 
You should be able to take input from end-users, discuss the requirements with your colleagues and the product owner, conceive a software architecture, define a technical stack. 
It is up to you whether you want to be involved in those critical decision-linked tasks. 
You may want to focus only on *"coding"*. I have two main objections: this is more error-prone and I doubt you will be able to work in a mature, agile and self-organized team.

## 2. Understand Agile, don't just apply a process/framework

Today, it is rare to find people that have never worked or heard of agile methods. You've probably experienced working in a team that uses an agile method such as Scrum. But doing scrum by the book is not a measure of your team's agility. 
On the one hand, I've seen very mature agile teams have quite different ceremonies and processes than the ones put forward by the Scrum methodology. 
On the other hand, some teams apply the method scrupulously but don't achieve very good results.

<div style="width:100%;height:0;padding-bottom:56%;position:relative;"><iframe src="https://giphy.com/embed/xT1XGOGdyDrL2BTfxK" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/siliconvalleyhbo-xT1XGOGdyDrL2BTfxK">via GIPHY</a></p>

To understand why, you need to put your practices in perspective. I once heard a very inspiring product owner say:

> "Scrum is to Agility what elections are to a democracy. Just as a country that holds elections is not necessarily a democracy, applying scrum does not guarantee your team is agile."

Your end goal should always be to strive for agility. At its root, agile is quite straight forward: 4 core values and 12 principles. 
If you look at the [agile manifesto](https://agilemanifesto.org), you should have a pretty good idea of how well your team is doing.

The aim of a framework such as Scrum is to help you on your way to becoming agile. That is why people are keen on applying agile methods. They aren't an immediate solution, they are a tool.

![Shu Ha Ri](shu-ha-ri.png)

So of course, I am not telling you to throw away frameworks such as scrum. 
They will give you a process on your way to agility. Do follow the rules strictly at first if you are learning **(SHU)**.
Once you are fully comfortable with the method, you can start adapting it to your own needs **(HA)** and emancipating **(RI)**.

## 3. Become a software craftsman

If you are just coding to achieve immediate results you are doing something wrong.
The quality of your code matters!
There are important software KPIs that you must look after such as:
* Unit tests and quality gates 
* The ease to refactor and maintain the codebase
* Ability to extend the existing codebase
* Management of dependencies
* Separation of concerns

If you don't pay attention to these key indicators, you'll end up building crappy code and crappy code does not scale!
Whatever reason you are invoking (stakeholder pressure, lack of time, it works on my machine, not knowing the better alternative etc.) can't justify rushing through the development phase.
You'll only end up with short-term customer satisfaction, sacrificing the long-term stability and scalability of your product.

I am not saying you should always aim for a perfect code and not settle for less. 
I'm saying that if you know that you are deliberately doing something wrong then you shouldn't do it.

The main difference I see between a junior developer and a senior developer is their ability to foresee difficulties and thus make right choices.
It is important to understand that code **changes** rapidly for a number of reasons (technological changes, business changes, architectural changes etc.). 
Thus, you should not only build software to make things work. You should also ensure it will be able to change rapidly at little cost.

Again, this takes a lot of time. 
Tools such as: Design Patterns, Clean Code, Clean Architecture, Solid Principles can help to build better quality code.

## 4. Don't be a fashion victim / tech zealot

![Tech Zealot](tech-zealot.jpeg)

You can be very enthusiastic but avoid being fanatical about new frameworks and novelties in the tech industry. 
Sure they might seem very trendy, popular and bankable on your job resume. 
If you are really interested in them, go ahead, work on them during your free time! 
However, in the workplace, the choice to work on a certain technology should always be motivated by its need and whether it is well-suited for your project context.
You must keep that in mind when you are choosing your tech stack.

The same applies to project guidelines or team practices. Don't always take them for granted. 
Even though they might work well for your team and be well-suited to your size and type of project, they won't always apply. 
It is very rare that you'll encounter a undisputed absolute truth. 
If you do, I would argue it is not a project or team practice but recognised as a best practice or design pattern.

Similarly to fashion or tv series, technology obeys the same rules. 
You might be using the "next best thing" or the "hottest piece of tech" at the moment. 
But these trends don't last eternally and continuously renew themselves. 
Furthermore, some languages and tools might be appealing because they are brand new but the concepts or patterns they apply are not. T
his brings us to the next point.

## 5. Understand underlying concepts

Of course, you want to master the languages and tools that you use. However, you should also focus on the broader concepts these tools are built on or use.

The following examples list areas you might want to explore if you are interested and use some associated technologies/examples that make use of these:

- JVM environment (Java, Kotlin, Scala, Groovy etc.)
- Inversion of Control / Dependency Injection (Spring framework)
- Containers (Docker)
- Virtual DOM (React)
- Store (Redux)
- Component approach/ Web components (React, Vue, Polymer etc.)
- CSS, BEM (preprocessors SASS, SCSS, Less)
- REST and SOAP architectures (JAX-RS, JAX-WS, expressjs etc.)
- OpenID Connect (OAuth 2)
- JavaScript (ES6, ES2020, TypeScript etc.)

Many people have practiced TypeScript although they don't fully understand JavaScript code mechanisms.

If you really understand a concept you'll have an undisputable head start in relation to those who don't. 
You'll have a deeper understanding of the implementations of that concept and be able to transpose them to other contexts.

## 6. Get to the bottom of things

- Boy Scout Rule
- Always look for the root cause of a problem
- Don't look for the hacky/short-term solution

## 7. Broaden your knowledge / skillset

- Craftmanship: Clean Code, Clean Architecture, Solid principles, Design Patterns etc.
- DevOps topics
- Cross-functional knowledge
- Learn to learn - Flatten the learning curve

## 8. Be humble & patient

<div style="width:100%;height:0;padding-bottom:56%;position:relative;"><iframe src="https://giphy.com/embed/5wWf7H89PisM6An8UAU" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/editingandlayout-the-office-michael-scott-5wWf7H89PisM6An8UAU">via GIPHY</a></p>

When you find yourself explaining something or sharing knowledge with a colleague, you should always remain humble and patient with your audience.

Good teachers aren't those who explain the most complicated subject. 
They are those who can make complex and intricate concepts accessible to anyone.

If something is hard to understand, you should be able to vulgarize and explain it to an audience. 
If you find that exercise difficult, you might want to question yourself on whether you truly understand what you are tying to explain. In the past, I have found myself in a situation where I believed I mastered something but explaining it to others was a real challenge. There shouldn't be any shame in that, it simply means that maybe the extent to which I thought I understood a subject wasn't as deep as I imagined it to be in the first place.

Also, you should always adapt what you are saying to the person in front of you. You'll definitely find yourself in situations where you believe someone or yourself to be a slow-learner. Remember where you come from and that no matter your age or experience, there will always be things that some will master quicker than others. We don't all have the same areas of expertise, experience with the same subjects of same learning reflexes. Generally speaking, don't blame the audience, question yourself on whether your approach is the best one.

## 9. Make mistakes… again and again

<div style="width:100%;height:0;padding-bottom:100%;position:relative;"><iframe src="https://giphy.com/embed/67urFpVn7qwcd2gWIl" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/netflix-santa-clarita-diet-67urFpVn7qwcd2gWIl">via GIPHY</a></p>

> *"You Miss 100% Of The Shots You Don't Take"* - Wayne Gretzky

I'm half-Canadian, this quote always was a motto for me. You've certainly heard it a hundred different ways. You don't fail by trying, you fail by not trying. By trying, you may surpass yourself in ways you didn't think possible. If you do end up failing, you'll learn a lot from your mistakes. That's a pretty good trade-off in my opinion.

I would even take this a step further and make a parallel with fail-fast designs: detect your mistakes as soon as possible. Detect and learn from them, they will pave the way for your future successes.

Now this might sound difficult especially if you are young and just starting out in a certain field. 
You might lack self-confidence or be afraid of making mistakes. 
For example, you're entrusted to lead a critical feature or to test the integration of a certain framework on your project and give a presentation of your results to your team. T
his kind of responsibility can be intimidating at first. 
Let me tell you this: the people who entrusted you with this task know your potential, so trust yourself and take initiatives. 
The only regret you'll have is if you don't try hard enough.

So the main idea is this: get out of your comfort zone! Try new things, give your best and let your creativity flow. Taking risks will benefit you, one way or the other.

## 10. Adapt continuously

When changes arrive in your work whether they are technical, organizational or human, you should accept them. 
Furthermore, you should welcome change and look at it as a new opportunity.


## Conclusion

A lot of these guidelines are deeply intertwined.
Generally speaking, work hard, be pragmatic, curious, get to the bottom of things, continuously assess yourself, have fun
